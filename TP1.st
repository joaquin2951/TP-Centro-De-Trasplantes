Object subclass: #CentroTransplantes	instanceVariableNames: 'nombre pacientes donantes evaluadorCompatibilidad asociaciones compatibilidades'	classVariableNames: ''	package: 'TP1'!!CentroTransplantes methodsFor: 'as yet unclassified' stamp: 'jh 10/4/2025 16:36'!calculaCompatibilidadesRegistrados 	"asociaciones es un diccionario que tiene keys->paciente y value->donante"	asociaciones keysDo:[:paciente | 									self compatibilidad: paciente con: (asociaciones at:paciente). 							].! !!CentroTransplantes methodsFor: 'as yet unclassified' stamp: 'jh 10/4/2025 18:28'!generarArchivoCompatibilidades: prefijoNombreArchivo			|contenido archivoNombre archivo compatibilidadesTrue|						"ResultadoCompatibilidad rc calculado, tal que rc compatible retorne true,"						compatibilidadesTrue	:= compatibilidades select: [:c | c compatible .].											"Genero el contenido CSV utilizando un WriteStream sobre un String."			contenido := String streamContents: 						[ :stream |    																compatibilidadesTrue do:[:compatibilidad| |dniPac dniDon porcentajeCompatibilidad|																		dniPac := compatibilidad paciente dni.									dniDon := compatibilidad donante dni.									porcentajeCompatibilidad  := compatibilidad porcentajeCompatibilidad.																								"Para cada resultado Compatibilidad escribo los campos, separados por comas. La línea termina con un salto de línea (nl)."       			 			stream nextPutAll: dniPac ; nextPut: $,.       					   stream nextPutAll: dniDon; nextPut: $,.        						stream nextPutAll: porcentajeCompatibilidad asString; cr."o ;nl"							].									            					].								"asignamos el nombre al archivo CSV"				archivoNombre := prefijoNombreArchivo,'_compatibilidades.csv'.							"Creo una referencia al archivo (esto es lo recomendado desde Pharo 8+)"					"archivo := FileLocator documents / archivoNombre."					archivo := FileLocator workingDirectory / archivoNombre.				"Escribo el contenido en el archivo con FileReference"					archivo writeStreamDo: [ :stream | stream nextPutAll: contenido ].										! !!CentroTransplantes methodsFor: 'as yet unclassified' stamp: 'jh 10/4/2025 18:09'!generarArchivoDonantes: prefijoNombreArchivo			| contenido archivoNombre archivo|						"Genero el contenido CSV utilizando un WriteStream sobre un String."			contenido := String streamContents: 						[ :stream |    																asociaciones keysDo:[:pac | |dniDonante nombreDonante apellido dniPaciente donante|																		donante := asociaciones at:pac.																		dniDonante := donante dni.									nombreDonante := donante nombre.									apellido  := donante apellido.									dniPaciente := pac dni.																								"Para cada paciente escribo los campos, separados por comas. La línea termina con un salto de línea (nl)."       			 			stream nextPutAll: dniDonante ; nextPut: $,.       					   stream nextPutAll: nombreDonante; nextPut: $,.        						stream nextPutAll: apellido; nextPut: $,.        						stream nextPutAll: dniPaciente asString; cr."o ;nl"							].									            					].								"asignamos el nombre al archivo CSV"				archivoNombre := prefijoNombreArchivo,'_donantes.csv'.							"Creo una referencia al archivo (esto es lo recomendado desde Pharo 8+)"					"archivo := FileLocator documents / archivoNombre."					archivo := FileLocator workingDirectory / archivoNombre.				"Escribo el contenido en el archivo con FileReference"					archivo writeStreamDo: [ :stream | stream nextPutAll: contenido ].																							! !!CentroTransplantes methodsFor: 'as yet unclassified' stamp: 'Anonymous 9/7/2025 10:41'!agregaDonante: unDonantedonantes add: unDonante.! !!CentroTransplantes methodsFor: 'as yet unclassified' stamp: 'jh 10/4/2025 18:17'!guardaRegistros: prefijoNombreArchivo 	self generarArchivoPacientes: prefijoNombreArchivo.	self generarArchivoDonantes: prefijoNombreArchivo.	self generarArchivoCompatibilidades: prefijoNombreArchivo.	! !!CentroTransplantes methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 10:53'!agregaPaciente: unPaciente fechaIngreso: unaFecha	|colTemporal|	colTemporal := OrderedCollection new.	colTemporal add: unPaciente.	colTemporal add: unaFecha.	pacientes add: colTemporal.! !!CentroTransplantes methodsFor: 'as yet unclassified' stamp: 'jh 10/4/2025 16:25'!inicializar	pacientes := OrderedCollection new.	donantes := OrderedCollection new.	asociaciones := Dictionary new.	compatibilidades := OrderedCollection new.! !!CentroTransplantes methodsFor: 'as yet unclassified' stamp: 'jh 10/4/2025 16:28'!compatibilidad: unPaciente con: unDonante		|resultado|		evaluadorCompatibilidad ifNil:[self error: 'no se ha definido ningun evaluador'].				"Si existe el evaluador, obtiene un objeto ResultadoCompatibilidad para el par (paciente, donante)"		resultado := evaluadorCompatibilidad compatibilidadPaciente: unPaciente con: unDonante.				compatibilidades add: resultado.		^resultado.! !!CentroTransplantes methodsFor: 'as yet unclassified' stamp: 'jh 10/4/2025 16:47'!calculaCompatibilidadesGeneral		"pacientes es una OrderedColeccition donde cada elemento es una OrderedCollection que tiene en su primera posicion el paciente en cuestion y"		"en la segunda posicion, una fecha de ingreso al Centro"		pacientes do:[:pac | 								donantes do:[:don |														self compatibilidad: (pac at:1) con: don. 												]						]! !!CentroTransplantes methodsFor: 'as yet unclassified' stamp: 'Anonymous 9/12/2025 16:06'!asociaPaciente: unaPersona conDonante: otraPersona"las key´s las consideramos como los Pacientes y los valores son los Donantes."asociaciones at: unaPersona put: otraPersona. ! !!CentroTransplantes methodsFor: 'as yet unclassified' stamp: 'jh 10/4/2025 17:54'!generarArchivoPacientes: prefijoNombreArchivo			|fechaActual contenido archivoNombre archivo|						fechaActual := Date today.									"Genero el contenido CSV utilizando un WriteStream sobre un String."			contenido := String streamContents: 						[ :stream |    																pacientes do:[:pac | |dni nombrePac apellido fechaIngreso cantMesesEnEspera|																dni := (pac at:1) dni.								nombrePac := (pac at:1) nombre.								apellido := (pac at:1) apellido.								fechaIngreso := (pac at:2).																cantMesesEnEspera := (fechaActual year - fechaIngreso year) * 12.																fechaActual month index >= fechaIngreso month index  								ifTrue:[ cantMesesEnEspera := cantMesesEnEspera + (fechaActual month index - fechaIngreso month index) ]								ifFalse:[ cantMesesEnEspera := cantMesesEnEspera - (fechaIngreso month index - fechaActual month index)].																"Para cada paciente escribo los campos, separados por comas. La línea termina con un salto de línea (nl)."       			 			stream nextPutAll: dni; nextPut: $,.       					   stream nextPutAll: nombrePac; nextPut: $,.        						stream nextPutAll: apellido; nextPut: $,.        						stream nextPutAll: cantMesesEnEspera asString; cr."o ;nl"							].									            					].								"asignamos el nombre al archivo CSV"				archivoNombre := prefijoNombreArchivo,'_pacientes.csv'.							"Creo una referencia al archivo (esto es lo recomendado desde Pharo 8+)"					"archivo := FileLocator documents / archivoNombre."					archivo := FileLocator workingDirectory / archivoNombre.				"Escribo el contenido en el archivo con FileReference"					archivo writeStreamDo: [ :stream | stream nextPutAll: contenido ].																							! !!CentroTransplantes methodsFor: 'accessing' stamp: 'jh 10/5/2025 11:43'!compatibilidades	^compatibilidades! !!CentroTransplantes methodsFor: 'accessing' stamp: 'Anonymous 9/7/2025 10:07'!nombre: unNombre	"recibe el unNombre como argumento y lo guarda en el atributo de nombre del objeto receptor"	nombre := unNombre.	! !!CentroTransplantes methodsFor: 'accessing' stamp: 'jh 10/5/2025 16:16'!evaluadorCompatibilidad: unEvaluador	evaluadorCompatibilidad := unEvaluador.	compatibilidades := OrderedCollection new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CentroTransplantes class	instanceVariableNames: ''!!CentroTransplantes class methodsFor: 'as yet unclassified' stamp: 'Anonymous 9/7/2025 10:38'!conNombre: unNombre	"devuelve una instancia de CentroTransplantes, con el nombre pasado como argumento"	|centro|.	centro := super new.	centro inicializar. "inicializa la lista de pacientes y de donantes como una Ordered Collection"	centro nombre:unNombre. "le asignamos el nombre al nuevo centro creado"	 ^(centro).! !Object subclass: #Criterio	instanceVariableNames: 'estudiosFaltantes sePuedeEvaluar'	classVariableNames: ''	package: 'TP1'!!Criterio methodsFor: 'as yet unclassified' stamp: 'jh 10/4/2025 14:41'!estudiosFaltantes: unPaciente con: unDonante	self subclassResponsibility.	! !!Criterio methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 11:58'!evaluaCompatibilidad: unPaciente con: unDonante	self subclassResponsibility.! !!Criterio methodsFor: 'accessing' stamp: 'jh 10/4/2025 14:32'!estudiosFaltantes 	^estudiosFaltantes ! !!Criterio methodsFor: 'accessing' stamp: 'jh 9/24/2025 11:56'!sePuedeEvaluar	^sePuedeEvaluar ! !Criterio subclass: #CriterioDeseable	instanceVariableNames: 'porcentajeCompatibilidad'	classVariableNames: ''	package: 'TP1'!!CriterioDeseable methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 12:02'!estudiosFaltantes: unPaciente con: unDonante	self subclassResponsibility .! !!CriterioDeseable methodsFor: 'as yet unclassified' stamp: 'jh 9/24/2025 11:18'!evaluaCompatibilidad: unPaciente con: unDonante	self subclassResponsibility.! !Criterio subclass: #CriterioObligatorio	instanceVariableNames: 'condicion'	classVariableNames: ''	package: 'TP1'!!CriterioObligatorio methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 12:01'!estudiosFaltantes: unPaciente con: unDonante	self subclassResponsibility.! !!CriterioObligatorio methodsFor: 'as yet unclassified' stamp: 'jh 9/24/2025 11:18'!evaluaCompatibilidad: unPaciente con: unDonante	self subclassResponsibility.! !CriterioObligatorio subclass: #ABO	instanceVariableNames: 'f'	classVariableNames: ''	package: 'TP1'!!ABO methodsFor: 'as yet unclassified' stamp: 'jh 9/24/2025 12:05'!estudiosFaltantes: unPaciente con: unDonante	"Se requieren análisis de sangre del paciente y del donante.Estudios: AnalisisDeSangre, con atributo grupoSanguineo."	estudiosFaltantes := OrderedCollection new.	unPaciente estudiosClinicos		detect: [ :e | e class = AnalisisDeSangre ]		ifNone: [ estudiosFaltantes add: 'AnalisisDeSangre' ].	unDonante estudiosClinicos		detect: [ :e | e class = AnalisisDeSangre ]		ifNone: [ estudiosFaltantes add: 'AnalisisDeSangre' ].	sePuedeEvaluar := estudiosFaltantes isEmptyOrNil		                  ifTrue: [ true ]		                  ifFalse: [ false ]! !!ABO methodsFor: 'as yet unclassified' stamp: 'jh 10/4/2025 16:09'!evaluaCompatibilidad: unPaciente con: unDonante		self estudiosFaltantes: unPaciente con: unDonante.		self sePuedeEvaluar ifFalse:[self error: 'faltan estudios para realizar la evaluación']			ifTrue:[					|estudioPaciente estudioDonante|									estudioPaciente := unPaciente estudioEspecifico: AnalisisDeSangre.  "buscamos el estudio del Analisis de Sangre"					estudioDonante := unDonante estudioEspecifico: AnalisisDeSangre.										estudioPaciente := estudioPaciente resultado. "obtenemos los resultados del analisis de sangre"					estudioDonante := estudioDonante resultado.										"el resultado de #apto o #noApto se guardara en la variable de instancia 'condicion' "										condicion := 										(estudioDonante = #A and:[estudioPaciente = #A | (estudioPaciente = #AB)]) 									|										(estudioDonante = #B and:[estudioPaciente = #B | (estudioPaciente = #AB)])									|											(estudioPaciente = #AB & (estudioDonante = #AB))									| (estudioDonante = #O).														condicion ifTrue: [ condicion := #apto ] ifFalse:[ condicion := #noApto ].																		^condicion.				].! !CriterioObligatorio subclass: #Crossmatch	instanceVariableNames: 'g'	classVariableNames: ''	package: 'TP1'!!Crossmatch methodsFor: 'as yet unclassified' stamp: 'jh 9/24/2025 12:07'!estudiosFaltantes: unPaciente con: unDonante	"Se requiere una prueba cruzada (crossmatch) específica entre el donante y el paciente.		Estudio: EstudioCrossmatch, con resultado #positivo o #negativo"		|aux|		estudiosFaltantes := OrderedCollection new.		aux := unPaciente estudiosClinicos reject: [:e | e isKindOf: EstudioClinico].		"de unPaciente obtenemos su coleccion de estudiosClinicos. De esa coleccion, filtramos solo		los elementos que no sean instacia de la clase EstudioClinico(o alguna subclase en este caso).		Hacemos el filtro porque en la coleccion estudiosClinicos podemos tener instacias de distintos 	estudios pero también podemos tener una instancia de una coleccion que tenga un EstudioClinico asociado con un donante especifico. 		Ejemplo de un estudiosClinicos de un paciente: (instanciaAnalisisDeSangre, instanciaIMC, OrderedColecction(instanciaCrossmatch, instanciaDonante))" 				aux isEmptyOrNil ifTrue:[estudiosFaltantes add: 'EstudioCrossMatch'] "no hay estudio Crossmatch realizado con ningun donante"							ifFalse:[								"hay estudios asociados a donantes, pero debemos detectar si hay un EstudioCrossMatch y que esté asociado a al donante unDonante"									aux detect:[:c | (c at:1) class = EstudioCrossMatch   and:[ (c at:2) = unDonante ] ]													ifNone:[estudiosFaltantes add: 'EstudioCrossMatch'].								].										sePuedeEvaluar := estudiosFaltantes isEmptyOrNil		                  ifTrue: [ true ]		                  ifFalse: [ false ]												! !!Crossmatch methodsFor: 'as yet unclassified' stamp: 'jh 9/24/2025 14:16'!evaluaCompatibilidad: unPaciente con: unDonante		self estudiosFaltantes: unPaciente con: unDonante.		self sePuedeEvaluar ifFalse:[self error: 'faltan estudios para realizar la evaluación']			ifTrue:[					|estudio|									estudio := unPaciente estudioEspecifico: EstudioCrossMatch  asociadoA: unDonante .					estudio := estudio resultado.										"el resultado de #apto o #noApto se guardara en la variable de instancia 'condicion' "										condicion := 										estudio = #positivo 									ifTrue:[#noApto] 									ifFalse:[#apto].																		^condicion.				].! !CriterioDeseable subclass: #Edad	instanceVariableNames: 'p'	classVariableNames: ''	package: 'TP1'!!Edad methodsFor: 'as yet unclassified' stamp: 'jh 10/4/2025 16:04'!estudiosFaltantes: unPaciente con: unDonante	sePuedeEvaluar := true. "ya que la edad siempre se calcula desde que creamos a la persona con su fecha de nacimiento"! !!Edad methodsFor: 'as yet unclassified' stamp: 'jh 10/3/2025 16:07'!evaluaCompatibilidad: unPaciente con: unDonante		|edadPaciente edadDonante diferencia|				sePuedeEvaluar := true. "ya que las edades ya están cargadas cuando se instancia la persona"							edadPaciente := unPaciente edad.  					edadDonante := unDonante edad.								diferencia := (edadDonante - edadPaciente)abs.									porcentajeCompatibilidad := ( 0 max:(1 - (diferencia/30) ) ) * 100. 														^porcentajeCompatibilidad.				! !CriterioObligatorio subclass: #EstadoClinicoDelDonante	instanceVariableNames: 'z'	classVariableNames: ''	package: 'TP1'!!EstadoClinicoDelDonante methodsFor: 'as yet unclassified' stamp: 'jh 9/24/2025 12:07'!estudiosFaltantes: unPaciente con: unDonante"Estudio: EstudioAptitudGeneral"		estudiosFaltantes := OrderedCollection new."Se requiere una evaluación general de la aptitud del donante para someterse a la cirugía y tener un riñón menos luego de la misma."		unDonante estudiosClinicos detect: [:e | e class = EstudioAptitudGeneral ] 						ifNone: [ estudiosFaltantes add: 'EstudioAptitudGeneral' ]. 							sePuedeEvaluar := estudiosFaltantes isEmptyOrNil		                  ifTrue: [ true ]		                  ifFalse: [ false ]					! !!EstadoClinicoDelDonante methodsFor: 'as yet unclassified' stamp: 'jh 10/5/2025 12:13'!evaluaCompatibilidad: unPaciente con: unDonante		self estudiosFaltantes: unPaciente con: unDonante.		self sePuedeEvaluar ifFalse:[self error: 'faltan estudios para realizar la evaluación']			ifTrue:[					|estudio|									estudio := unDonante estudioEspecifico: EstudioAptitudGeneral.					estudio := estudio resultado.										"el resultado de #apto o #noApto se guardara en la variable de instancia 'condicion' "										condicion := 										estudio = #apto 									ifTrue:[#apto] 									ifFalse:[#noApto].																		^condicion.				].! !Object subclass: #EstudioClinico	instanceVariableNames: 'd'	classVariableNames: ''	package: 'TP1'!EstudioClinico subclass: #AnalisisDeSangre	instanceVariableNames: 'grupoSanguineo'	classVariableNames: ''	package: 'TP1'!!AnalisisDeSangre methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 12:22'!conResultado: unGrupoSanguineogrupoSanguineo := unGrupoSanguineo.! !!AnalisisDeSangre methodsFor: 'as yet unclassified' stamp: 'jh 9/24/2025 11:27'!resultado	^grupoSanguineo .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AnalisisDeSangre class	instanceVariableNames: ''!!AnalisisDeSangre class methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 12:22'!conGrupoSanguineo: unGrupoSanguineo	|temp|	temp:=self new.	^temp conResultado: unGrupoSanguineo.	! !EstudioClinico subclass: #EstudioAnticuerposPRA	instanceVariableNames: 'locus'	classVariableNames: ''	package: 'TP1'!!EstudioAnticuerposPRA methodsFor: 'as yet unclassified' stamp: 'mateo 9/15/2025 14:06'!inicializar: arregloA  b: arregloB dR: arregloDR"a inicializar: #(A3, 15) b: #(B1,20) "locus := Dictionary new."las llaves son los primeros elementos del arreglo, y los valores los segundos elementos"locus at: (arregloA at:1) put: (arregloA at:2).locus at: (arregloB at:1) put: (arregloB at:2).locus at: (arregloDR at:1) put: (arregloDR at:2).! !!EstudioAnticuerposPRA methodsFor: 'accessing' stamp: 'jh 10/3/2025 15:00'!locus^locus! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstudioAnticuerposPRA class	instanceVariableNames: ''!!EstudioAnticuerposPRA class methodsFor: 'as yet unclassified' stamp: 'jh 9/12/2025 17:20'!conA: aleloA   b: aleloB dR: aleloDR^self new inicializar: aleloA  b: aleloB dR: aleloDR! !EstudioClinico subclass: #EstudioAptitudGeneral	instanceVariableNames: 'resultado'	classVariableNames: ''	package: 'TP1'!!EstudioAptitudGeneral methodsFor: 'accessing' stamp: 'jh 10/5/2025 12:15'!resultado^resultado! !!EstudioAptitudGeneral methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 12:22'!conResultado: unResultadoresultado := unResultado.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstudioAptitudGeneral class	instanceVariableNames: ''!!EstudioAptitudGeneral class methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 12:22'!conResultado: unResultado^self new conResultado: unResultado.! !EstudioClinico subclass: #EstudioCrossMatch	instanceVariableNames: 'resultado'	classVariableNames: ''	package: 'TP1'!!EstudioCrossMatch methodsFor: 'accessing' stamp: 'jh 9/24/2025 14:17'!resultado	^resultado! !!EstudioCrossMatch methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 12:22'!conResultado: unResultadoresultado := unResultado.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstudioCrossMatch class	instanceVariableNames: ''!!EstudioCrossMatch class methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 12:22'!conResultado: unResultado^self new conResultado: unResultado.! !EstudioClinico subclass: #EstudioIMC	instanceVariableNames: 'resultado'	classVariableNames: ''	package: 'TP1'!!EstudioIMC methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 12:22'!conResultado: unaPersona|peso altura|peso := unaPersona peso .altura:= unaPersona estatura .altura := altura*altura.resultado := peso / altura! !!EstudioIMC methodsFor: 'accessing' stamp: 'jh 10/3/2025 15:30'!resultado^resultado! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstudioIMC class	instanceVariableNames: ''!!EstudioIMC class methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 12:22'!paraPersona: unaPersona^(self new) conResultado: unaPersona ! !EstudioClinico subclass: #EstudioSerologicoCompleto	instanceVariableNames: 'resultado'	classVariableNames: ''	package: 'TP1'!!EstudioSerologicoCompleto methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 12:22'!conResultado: unResultadoresultado := unResultado.! !!EstudioSerologicoCompleto methodsFor: 'accessing' stamp: 'jh 10/3/2025 14:26'!resultado ^resultado! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstudioSerologicoCompleto class	instanceVariableNames: ''!!EstudioSerologicoCompleto class methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 12:22'!conResultado: unResultado^self new conResultado: unResultado.! !EstudioClinico subclass: #EstudioTipificacionHLA	instanceVariableNames: 'resultadoA resultadoB resultadoDR'	classVariableNames: ''	package: 'TP1'!!EstudioTipificacionHLA methodsFor: 'as yet unclassified' stamp: 'jh 10/3/2025 14:51'!conResultadoA: conA b: conB dR: conDRresultadoA := conA.resultadoB := conB.resultadoDR := conDR.! !!EstudioTipificacionHLA methodsFor: 'accessing' stamp: 'jh 10/3/2025 14:35'!resultadoA^resultadoA! !!EstudioTipificacionHLA methodsFor: 'accessing' stamp: 'jh 10/3/2025 14:35'!resultadoB^resultadoB ! !!EstudioTipificacionHLA methodsFor: 'accessing' stamp: 'jh 10/3/2025 14:35'!resultadoDR^resultadoDR ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstudioTipificacionHLA class	instanceVariableNames: ''!!EstudioTipificacionHLA class methodsFor: 'as yet unclassified' stamp: 'jh 10/3/2025 14:51'!conA: resultadoA b: resultadoB dR: resultadoDR^self new conResultadoA: resultadoA b: resultadoB dR: resultadoDR! !Object subclass: #EvaluadorCompatibilidad	instanceVariableNames: 'criteriosObligatorios criteriosDeseables'	classVariableNames: ''	package: 'TP1'!!EvaluadorCompatibilidad methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 11:31'!agregarCriterioDeseable: unCriterio ponderacion: unaPonderacion		(unCriterio isKindOf: CriterioDeseable ) 									ifFalse:											  [self error:'lo que intenta agregar NO es un criterioDeseable']									ifTrue:											  [criteriosDeseables  at:unCriterio put:unaPonderacion]. ! !!EvaluadorCompatibilidad methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 11:22'!agregarCriterioObligatorio: unCriterio		(unCriterio isKindOf: CriterioObligatorio) 									ifFalse:											  [self error:'lo que intenta agregar NO es un criterioObligatorio']									ifTrue:											  [criteriosObligatorios add: unCriterio.] ! !!EvaluadorCompatibilidad methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 11:29'!inicializar	criteriosObligatorios := OrderedCollection new.	criteriosDeseables := Dictionary  new."cada criterio deseable tiene asociada una ponderacion"	"Cada criterio solo va a aparecer una vez. No puede haber criterios repetidos."! !!EvaluadorCompatibilidad methodsFor: 'as yet unclassified' stamp: 'jh 10/4/2025 15:33'!compatibilidadPaciente: unPaciente con: unDonante"El objeto retornado debe ser una instancia de ResultadoCompatibilidad"	|acumulador sumaPonderaciones estudiosFaltantes|		estudiosFaltantes := OrderedCollection new.	"evaluar cada criterio obligatorio"	criteriosObligatorios do:[:criterio | |fs|										criterio estudiosFaltantes: unPaciente  con: unDonante.										fs := criterio estudiosFaltantes.										"si la lista está vacia, el criterio puede 	ser evaluado"										fs isEmptyOrNil ifFalse: [ fs do:[:f | estudiosFaltantes add:f ].  ]. "si fs no está vacia, se agrega cada estudio faltante a la coleccion de estudiosFaltantes" 																				(  "si el criterio no se puede evaluar o se puede evaluar pero su resultado es noApto, entonces vamos al paso 7"											(criterio sePuedeEvaluar = false)   											or:[ (criterio evaluaCompatibilidad: unPaciente  con: unDonante) = #noApto ] 										)										ifTrue: [  "vamos al paso 7, Terminación con incompatibilidad absoluta (porcentaje = 0)."														^ ResultadoCompatibilidad nuevoConPaciente: unPaciente   donante: unDonante   porcentajeCompatibilidad: 0  																						 																						 estudiosFaltantes: estudiosFaltantes .													].																				"si no se retornó en el ifTrue:[] , significa que el criterio sePuedeEvaluar y que su resultado es #apto"										"por lo tanto, se sigue iterando sobre el siguiente criterio."									].																		"evaluar cada criterio deseable (recordando que criteriosDeseables es un DICCIONARIO donde key->criterio value->ponderacionAsociada)"	acumulador := 0.	sumaPonderaciones := 0.		criteriosDeseables keysDo:[:criterio | |fs ponderacion|										"Para cada criterio deseable, se incrementa sumaPonderaciones con la ponderación asociada al criterio"										ponderacion := criteriosDeseables at:criterio.										sumaPonderaciones := sumaPonderaciones + ponderacion.																				criterio estudiosFaltantes: unPaciente  con: unDonante. 										fs := criterio estudiosFaltantes.																				"si la lista no está vacia, se agregan los nombres de los estudios faltantes a la coleccion estudiosFaltantes"										fs isEmptyOrNil ifFalse: [ fs do:[:f | estudiosFaltantes add:f ].  ].																				(criterio sePuedeEvaluar)   										ifTrue: [  													|valor|													"Si el criterio se puede evaluar, 													se procede a evaluar el criterio obteniendo como resultado un valor, 													que se acumula del siguiente modo:  acumulador = acumulador  + (ponderación * valor / 100)."																										valor := criterio evaluaCompatibilidad: unPaciente con: unDonante. 																										acumulador := acumulador + (ponderacion * valor / 100).																								].																														"Se sigue iterando sobre el siguiente criterio."									].														"Terminación con compatibilidad calculada"				"En este punto se cuenta con acumulador y sumaPonderaciones válidos para calcular un porcentaje de compatibilidad. "		^ ResultadoCompatibilidad nuevoConPaciente: unPaciente   donante: unDonante   porcentajeCompatibilidad: ( (acumulador/sumaPonderaciones) * 100 ) 																						 																						 estudiosFaltantes: estudiosFaltantes .				! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EvaluadorCompatibilidad class	instanceVariableNames: ''!!EvaluadorCompatibilidad class methodsFor: 'instance creation' stamp: 'jh 9/23/2025 11:15'!new	^super new inicializar.! !CriterioDeseable subclass: #HLA	instanceVariableNames: 'f'	classVariableNames: ''	package: 'TP1'!!HLA methodsFor: 'as yet unclassified' stamp: 'jh 10/3/2025 14:29'!estudiosFaltantes: unPaciente con: unDonante"Estudio: EstudioTipificacionHLA"		estudiosFaltantes := OrderedCollection new."Se requiere la tipificación HLA de donante y paciente"		unDonante estudiosClinicos detect: [:e | e class = EstudioTipificacionHLA  ] 						ifNone: [ estudiosFaltantes add: 'EstudioTipificacionHLA' ]. 		unPaciente estudiosClinicos detect: [:e | e class = EstudioTipificacionHLA ] 						ifNone: [ estudiosFaltantes add: 'EstudioTipificacionHLA' ].								sePuedeEvaluar := estudiosFaltantes isEmptyOrNil		                  ifTrue: [ true ]		                  ifFalse: [ false ]		! !!HLA methodsFor: 'as yet unclassified' stamp: 'jh 10/3/2025 14:49'!evaluaCompatibilidad: unPaciente con: unDonante		self estudiosFaltantes: unPaciente con: unDonante.		self sePuedeEvaluar ifFalse:[self error: 'faltan estudios para realizar la evaluación']			ifTrue:[					|estudioPaciente estudioDonante matches pacienteLocus donanteLocus|									estudioPaciente := unPaciente estudioEspecifico: EstudioTipificacionHLA .  "buscamos el estudio EstudioTipificacionHLA"					estudioDonante := unDonante estudioEspecifico: EstudioTipificacionHLA.										matches := 0.					pacienteLocus := estudioPaciente resultadoA. "nos devuelve un arreglo con el locusA de dos alelos"					donanteLocus := estudioDonante resultadoA.										pacienteLocus do:[:e1 | 												donanteLocus do:[:e2 |																	e1 = e2 ifTrue:[ matches := matches + 1. ]																	]																].														pacienteLocus := estudioPaciente resultadoB. "nos devuelve un arreglo con el locusB de dos alelos"					donanteLocus := estudioDonante resultadoB.										pacienteLocus do:[:e1 | 												donanteLocus do:[:e2 |																	e1 = e2 ifTrue:[ matches := matches + 1. ]																	]																].														pacienteLocus := estudioPaciente resultadoDR. "nos devuelve un arreglo con el locusDR de dos alelos"					donanteLocus := estudioDonante resultadoDR.										pacienteLocus do:[:e1 | 												donanteLocus do:[:e2 |																	e1 = e2 ifTrue:[ matches := matches + 1. ]																	]																].					"el resultado de #apto o #noApto se guardara en la variable de instancia 'condicion' "										porcentajeCompatibilidad := (matches / 6) * 100.																												^porcentajeCompatibilidad.				].! !CriterioDeseable subclass: #PRA	instanceVariableNames: ''	classVariableNames: ''	package: 'TP1'!!PRA methodsFor: 'as yet unclassified' stamp: 'jh 9/24/2025 12:08'!estudiosFaltantes: unPaciente con: unDonante"Requiere: EstudioTipificacionHLA del donante y EstudioAnticuerposPRA del paciente."		estudiosFaltantes := OrderedCollection new.		unDonante estudiosClinicos detect: [:e | e class = EstudioTipificacionHLA  ] 						ifNone: [ estudiosFaltantes add: 'EstudioTipificacionHLA' ]. 		unPaciente estudiosClinicos detect: [:e | e class = EstudioAnticuerposPRA  ] 						ifNone: [ estudiosFaltantes add: 'EstudioAnticuerposPRA' ].								sePuedeEvaluar := estudiosFaltantes isEmptyOrNil		                  ifTrue: [ true ]		                  ifFalse: [ false ]		! !!PRA methodsFor: 'as yet unclassified' stamp: 'jh 10/3/2025 15:20'!evaluaCompatibilidad: unPaciente con: unDonante		self estudiosFaltantes: unPaciente con: unDonante.		self sePuedeEvaluar ifFalse:[self error: 'faltan estudios para realizar la evaluación']			ifTrue:[					|estudioPaciente estudioDonante pacienteLocus suma  donanteLocus|									estudioPaciente := unPaciente estudioEspecifico: EstudioAnticuerposPRA  .  "buscamos el estudio EstudioAnticuerposPRA"					estudioDonante := unDonante estudioEspecifico: EstudioTipificacionHLA.										suma := 0.					donanteLocus := (estudioDonante resultadoA) , (estudioDonante resultadoB) , (estudioDonante resultadoDR) . "nos devuelve un arreglo con el locusA de dos alelos"					pacienteLocus := estudioPaciente locus. "nos retorna el diccionario que tiene asociado el paciente con los alelos como llaves y el porcentaje como valores"										donanteLocus do:[:l | 											(pacienteLocus includesKey: l)	ifTrue:[ suma := suma + (pacienteLocus at:l) ].										].															"el resultado de #apto o #noApto se guardara en la variable de instancia 'condicion' "					porcentajeCompatibilidad := 0 max:(100-suma). "suma > 100 ifTrue:[ 0 ] ifFalse:[ 100 - suma ]."																																						^porcentajeCompatibilidad.				].! !Object subclass: #Persona	instanceVariableNames: 'dni nombre apellido fechaNacimiento estatura peso estudiosClinicos'	classVariableNames: ''	package: 'TP1'!!Persona methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 11:11'!registraEstudio: unEstudioClinico con: unaPersona		|coleccionTemporal|		coleccionTemporal := OrderedCollection new.		coleccionTemporal add: unEstudioClinico.		coleccionTemporal add: unaPersona.			estudiosClinicos add: coleccionTemporal.! !!Persona methodsFor: 'as yet unclassified' stamp: 'Anonymous 9/12/2025 16:23'!inicializar: unDni nombre: unNombre apellido:unApellido fechaDeNacimiento:unaFecha	dni := unDni.	nombre := unNombre.	apellido := unApellido.	fechaNacimiento := unaFecha.	estudiosClinicos := OrderedCollection new.! !!Persona methodsFor: 'as yet unclassified' stamp: 'jh 9/24/2025 14:40'!estudioEspecifico: unEstudioABuscar asociadoA:unDonante		"se busca unEstudioABuscar asociado a unDonante en la lista de estudiosClinicos del receptor y lo retorna. Se supone que el Estudio debe existir."				|estudios|		estudios := self estudiosClinicos.		estudios := estudios reject:[:e | e isKindOf: EstudioClinico ].		estudios := estudios detect:[	:c | 									(c at:1) class = unEstudioABuscar 									and:[	(c at:2) = unDonante ]								].									^estudios at:1.! !!Persona methodsFor: 'as yet unclassified' stamp: 'jh 9/24/2025 11:42'!estudioEspecifico: unEstudioABuscar		"se busca unEstudioABuscar en la lista de estudiosClinicos del receptor y lo retorna. Se supone que el Estudio debe existir."		"ejemplo: juan estudioEspecifico: AnalisisDeSangre , retorna la instacia del estudio AnalisisDeSangre que tenga el paciente en su lista de estudiosClinicos "		|estudios|		estudios := self estudiosClinicos.		^ estudios detect:[:e | e class = unEstudioABuscar].! !!Persona methodsFor: 'as yet unclassified' stamp: 'jh 9/12/2025 16:26'!registraEstudio: unEstudioClinicoestudiosClinicos add: unEstudioClinico.! !!Persona methodsFor: 'as yet unclassified' stamp: 'jh 10/3/2025 16:05'!edad	|edad fechaActual|			fechaActual := Date today.	edad := (fechaActual year) - (fechaNacimiento year).	((fechaActual month < fechaNacimiento month) or: [   																		(fechaActual month = fechaNacimiento month) and: 																		[fechaActual day < fechaNacimiento day]																	]) 															  															  ifTrue: [edad := edad - 1].^edad.! !!Persona methodsFor: 'accessing' stamp: 'mateo 9/15/2025 14:41'!peso ^ peso! !!Persona methodsFor: 'accessing' stamp: 'mateo 9/15/2025 14:41'!estatura^estatura ! !!Persona methodsFor: 'accessing' stamp: 'jh 9/23/2025 12:04'!estudiosClinicos	^estudiosClinicos ! !!Persona methodsFor: 'accessing' stamp: 'jh 10/4/2025 16:57'!apellido	^apellido! !!Persona methodsFor: 'accessing' stamp: 'jh 10/4/2025 16:57'!dni^dni! !!Persona methodsFor: 'accessing' stamp: 'mateo 9/9/2025 19:31'!nombre: unNombre    nombre := unNombre! !!Persona methodsFor: 'accessing' stamp: 'Anonymous 9/12/2025 16:14'!peso: unPesopeso := unPeso! !!Persona methodsFor: 'accessing' stamp: 'Anonymous 9/12/2025 16:14'!estatura: unaEstaturaestatura := unaEstatura ! !!Persona methodsFor: 'accessing' stamp: 'mateo 9/9/2025 19:31'!nombre^nombre ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Persona class	instanceVariableNames: ''!!Persona class methodsFor: 'as yet unclassified' stamp: 'Anonymous 9/7/2025 10:30'!conDni: unDni nombre: unNombre apellido: unApellido fechaNacimiento: unaFecha	"retorna una instancia de persona inicializado con los parametros pasados como argumento"	|p|	p := super new.	p inicializar: unDni nombre: unNombre apellido:unApellido fechaDeNacimiento:unaFecha.	^p.! !Object subclass: #ResultadoCompatibilidad	instanceVariableNames: 'paciente donante estudiosFaltantes porcentajeCombatibilidad'	classVariableNames: 'minimoCompatibilidad'	package: 'TP1'!!ResultadoCompatibilidad methodsFor: 'accessing' stamp: 'jh 10/4/2025 18:07'!donante^donante! !!ResultadoCompatibilidad methodsFor: 'accessing' stamp: 'jh 9/23/2025 11:41'!estudiosFaltantes	^estudiosFaltantes ! !!ResultadoCompatibilidad methodsFor: 'accessing' stamp: 'jh 10/4/2025 18:07'!paciente^paciente! !!ResultadoCompatibilidad methodsFor: 'as yet unclassified' stamp: 'jh 10/4/2025 15:02'!inicializarConPaciente: unPaciente donante: unDonante porcentajeCompatibilidad: unPorcentaje estudiosFaltantes: unaListaNombresDeEstudio	paciente := unPaciente .	donante := unDonante .	porcentajeCombatibilidad := unPorcentaje .	estudiosFaltantes := unaListaNombresDeEstudio .! !!ResultadoCompatibilidad methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 11:41'!porcentajeCompatibilidad	^porcentajeCombatibilidad ! !!ResultadoCompatibilidad methodsFor: 'as yet unclassified' stamp: 'jh 10/4/2025 18:11'!minimoCompatibilidad: unMinimo	minimoCompatibilidad := unMinimo ! !!ResultadoCompatibilidad methodsFor: 'as yet unclassified' stamp: 'jh 9/23/2025 11:46'!compatible	|bool|	bool := porcentajeCombatibilidad  >=  minimoCompatibilidad.	^bool.	"Retorna true si el porcentaje de compatibilidad es mayor o igual al mínimo de compatibilidad, 	caso contrario retorna false."! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ResultadoCompatibilidad class	instanceVariableNames: ''!!ResultadoCompatibilidad class methodsFor: 'as yet unclassified' stamp: 'jh 10/4/2025 18:25'!minimoCompatibilidad: unMinimo	minimoCompatibilidad := unMinimo .	! !!ResultadoCompatibilidad class methodsFor: 'as yet unclassified' stamp: 'jh 10/4/2025 15:01'!nuevoConPaciente: unPaciente donante: unDonante porcentajeCompatibilidad: unPorcentaje estudiosFaltantes: unaListaNombresDeEstudios^self new inicializarConPaciente: unPaciente donante: unDonante porcentajeCompatibilidad: unPorcentaje estudiosFaltantes: unaListaNombresDeEstudios! !CriterioObligatorio subclass: #SerologiaActiva	instanceVariableNames: 'h'	classVariableNames: ''	package: 'TP1'!!SerologiaActiva methodsFor: 'as yet unclassified' stamp: 'jh 9/24/2025 12:07'!estudiosFaltantes: unPaciente con: unDonante"Estudios: EstudioSerologicoCompleto"		estudiosFaltantes := OrderedCollection new.		unPaciente estudiosClinicos detect: [:e | e class = EstudioSerologicoCompleto  ] 						ifNone: [ estudiosFaltantes add: 'EstudioSerologicoCompleto' ]. 								unDonante estudiosClinicos detect: [:e | e class = EstudioSerologicoCompleto ] 						ifNone: [ estudiosFaltantes add: 'EstudioSerologicoCompleto' ]. 									sePuedeEvaluar := estudiosFaltantes isEmptyOrNil		                  ifTrue: [ true ]		                  ifFalse: [ false ]					! !!SerologiaActiva methodsFor: 'as yet unclassified' stamp: 'jh 10/3/2025 14:24'!evaluaCompatibilidad: unPaciente con: unDonante		self estudiosFaltantes: unPaciente con: unDonante.		self sePuedeEvaluar ifFalse:[self error: 'faltan estudios para realizar la evaluación']			ifTrue:[					|estudioPaciente estudioDonante|									estudioPaciente := unPaciente estudioEspecifico: EstudioSerologicoCompleto .  "buscamos el estudio del EstudioSerologicoCompleto"					estudioDonante := unDonante estudioEspecifico: EstudioSerologicoCompleto.										estudioPaciente := estudioPaciente resultado. "obtenemos los resultados del estudio"					estudioDonante := estudioDonante resultado.										"el resultado de #apto o #noApto se guardara en la variable de instancia 'condicion' "										condicion := (estudioPaciente = #apto and:[estudioDonante = #apto]) ifTrue: [ #apto ] ifFalse: [ #noApto ].																		^condicion.				].! !CriterioDeseable subclass: #TamCorporal	instanceVariableNames: 'z'	classVariableNames: ''	package: 'TP1'!!TamCorporal methodsFor: 'as yet unclassified' stamp: 'jh 9/24/2025 12:07'!estudiosFaltantes: unPaciente con: unDonante"Requiere: EstudioTipificacionHLA del donante y EstudioAnticuerposPRA del paciente."		estudiosFaltantes := OrderedCollection new.		unDonante estudiosClinicos detect: [:e | e class = EstudioIMC   ] 						ifNone: [ estudiosFaltantes add: 'EstudioIMC' ]. 		unPaciente estudiosClinicos detect: [:e | e class = EstudioIMC  ] 						ifNone: [ estudiosFaltantes add: 'EstudioIMC' ].								sePuedeEvaluar := estudiosFaltantes isEmptyOrNil		                  ifTrue: [ true ]		                  ifFalse: [ false ]		! !!TamCorporal methodsFor: 'as yet unclassified' stamp: 'jh 10/3/2025 15:52'!evaluaCompatibilidad: unPaciente con: unDonante				self estudiosFaltantes: unPaciente con: unDonante.				self sePuedeEvaluar ifFalse:[self error: 'faltan estudios para realizar la evaluación']			ifTrue:[					|estudioPaciente estudioDonante diferencia|									estudioPaciente := unPaciente estudioEspecifico: EstudioIMC   .  "buscamos el estudio EstudioIMC"					estudioDonante := unDonante estudioEspecifico: EstudioIMC.										estudioPaciente := estudioPaciente resultado. "obtenemos el resultado de hacer peso / altura*altura"					"Transcript show: estudioPaciente."					estudioDonante := estudioDonante resultado.				   "Transcript show: estudioDonante."					diferencia := (estudioDonante - estudioPaciente)abs."abs retorna el valor absoluto del numero receptor"					"Transcript show: diferencia ."					porcentajeCompatibilidad := ( 0 max:(1 - (diferencia/10) ) ) * 100. 										"Transcript show: (1 - (diferencia/10)) ."																												^porcentajeCompatibilidad.				].! !